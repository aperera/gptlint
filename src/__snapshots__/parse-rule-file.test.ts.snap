// Vitest Snapshot v1, https://vitest.dev/guide/snapshot.html

exports[`parseRuleFile - fixtures/rules/empty-examples.md 1`] = `
{
  "desc": "This rule doesn't contain any examples which is fine because they are optional.",
  "message": "Example",
  "name": "example",
  "negativeExamples": [],
  "positiveExamples": [],
  "source": "fixtures/rules/empty-examples.md",
}
`;

exports[`parseRuleFile - fixtures/rules/force-list-pagination.md 1`] = `
{
  "desc": "Force the use of pagination for all lists in GraphQL.",
  "fixable": false,
  "languages": [
    "javascript",
    "typescript",
  ],
  "level": "error",
  "message": "Force List Pagination",
  "name": "force-list-pagination",
  "negativeExamples": [
    {
      "code": "type Query {
  items: [ItemConnection]
  requiredItems: [ItemConnection!]
  nestedRequireItems: [ItemConnection!]!
}",
      "language": "graphql",
    },
  ],
  "positiveExamples": [
    {
      "code": "type ListPaginationInput {
  first: Int
  last: Int
  after: String
  before: String
}

type Query {
  items(pagination: ): [ItemConnection]
  requiredItems: [ItemConnection!]
  nestedRequireItems: [ItemConnection!]!
}",
      "language": "graphql",
    },
  ],
  "source": "fixtures/rules/force-list-pagination.md",
  "tags": [
    "graphql",
  ],
}
`;

exports[`parseRuleFile - fixtures/rules/metadata-0.md 1`] = `
{
  "desc": "This example should parse correctly.",
  "eslint": [
    "example-eslint-rule-1",
    "example-eslint-rule-2",
  ],
  "fixable": false,
  "languages": [
    "javascript",
    "typescript",
  ],
  "level": "error",
  "message": "Example",
  "name": "example-name",
  "negativeExamples": [],
  "positiveExamples": [],
  "source": "fixtures/rules/metadata-0.md",
  "tags": [
    "general",
  ],
}
`;

exports[`parseRuleFile - fixtures/rules/metadata-1.md 1`] = `
{
  "desc": "This example should parse correctly because we stringify the values.",
  "eslint": [
    "example-eslint-rule-1",
    "@foo/example-eslint-rule-2",
  ],
  "fixable": false,
  "languages": [
    "javascript",
    "typescript",
  ],
  "level": "error",
  "message": "Example",
  "name": "example-name",
  "negativeExamples": [],
  "positiveExamples": [],
  "source": "fixtures/rules/metadata-1.md",
  "tags": [
    "general",
    "react",
  ],
}
`;

exports[`parseRuleFile - fixtures/rules/mutations.md 1`] = `
{
  "desc": "Disallow empty arguments for mutation Enforcing naming conventions for mutation input names and mutation return types.",
  "eslint": [
    "@ux-l_graphql-eslint/mutation-types",
  ],
  "fixable": false,
  "languages": [
    "javascript",
    "typescript",
  ],
  "level": "error",
  "message": "Mutation Inputs",
  "name": "mutation-types",
  "negativeExamples": [
    {
      "code": "type Mutation {
  setMessage(message: SetMessageInput, other: String): String
}
type Mutation {
  setMessage(message: String): String
}
type Mutation {
  setMessage: String
}
type Mutation {
  setMessage(input: setMessageInput): setMessageResponse
}",
      "language": "graphql",
    },
  ],
  "positiveExamples": [
    {
      "code": "type Mutation {
  setMessage(input: SetMessageInput): SetMessageResponse
}
type Mutation {
  setMessage(input: [SetMessageInput]): SetMessageResponse
}",
      "language": "graphql",
    },
  ],
  "source": "fixtures/rules/mutations.md",
  "tags": [
    "graphql",
  ],
}
`;

exports[`parseRuleFile - fixtures/rules/prefer-edge-node.md 1`] = `
{
  "desc": "Prefer usage of Edges and Nodes in GraphQL Lists.",
  "eslint": [
    "@ux-l_graphql-eslint/mutation-types",
  ],
  "fixable": false,
  "languages": [
    "javascript",
    "typescript",
  ],
  "level": "error",
  "message": "Prefer Edges & Nodes",
  "name": "prefer-edge-node",
  "negativeExamples": [
    {
      "code": "type Item {
  id: ID
  name: String
}

type Query {
  items: [Item]
  requiredItems: [Item!]
  nestedRequireItems: [Item!]!
}",
      "language": "graphql",
    },
  ],
  "positiveExamples": [
    {
      "code": "type Item {
  id: ID
  name: String
}

type ItemEdge {
  node: Node!
  cursor: String!
}

type ItemConnection {
  edges: [ItemEdge]
  pageInfo: PageInfo!
}

type PageInfo {
  endCursor: String
  hasNextPage: Boolean!
  resultCount: Int!
}

type Query {
  items: [ItemConnection]
  requiredItems: [ItemConnection!]
  nestedRequireItems: [ItemConnection!]!
}",
      "language": "graphql",
    },
  ],
  "source": "fixtures/rules/prefer-edge-node.md",
  "tags": [
    "graphql",
  ],
}
`;

exports[`parseRuleFile - fixtures/rules/prefer-page-queries.md 1`] = `
{
  "desc": "Warn on usage of the /utils/api.ts file in favor of creating a page query in the /utils/pageQueries folder.",
  "fixable": false,
  "languages": [
    "javascript",
    "typescript",
  ],
  "level": "error",
  "message": "Prefer page queries",
  "name": "prefer-page-queries",
  "negativeExamples": [
    {
      "code": "export const get<queryName>Data = async (
  locale: string
): Promise<<queryName>Type | null> => {
  try {
    const data = await fetchCmsGraphql(GET_<queryName>, {
      locale,
    });
    return data?.<queryName>?.data?.attributes || null;
  } catch (error) {
    console.error(error);
    return null;
  }
};",
      "language": "ts",
    },
  ],
  "positiveExamples": [
    {
      "code": "import { print } from 'graphql';
import {
  <queryName>Query,
  <queryName>QueryVariables,
} from './AboutUsPage.generated';
export type { <queryName>Query, <queryName>QueryVariables };
import QUERY from './AboutUsPage';
import { fetchCmsGraphql } from '../../fetchCmsData';

export const get<queryName>PageData = async (
  variables: <queryName>PageQueryVariables
): Promise<<queryName>Query | null> => {
  try {
    const data = await fetchCmsGraphql(print(QUERY), variables);
    return data as <queryName>Query;
  } catch (error) {
    console.error(error);
    return null;
  }
};",
      "language": "ts",
    },
    {
      "code": "import gql from 'graphql-tag'

export default gql\`
  query <queryName> {
    # query here
  }
\`",
      "language": "tsx",
    },
  ],
  "source": "fixtures/rules/prefer-page-queries.md",
  "tags": [
    "graphql",
  ],
}
`;

exports[`parseRuleFile - fixtures/rules/prefer-strapi-env-vars.md 1`] = `
{
  "desc": "Avoid accessing process.env variables in favor of Strapi environment variables.",
  "fixable": true,
  "languages": [
    "javascript",
    "typescript",
  ],
  "level": "error",
  "message": "Use Strapi Environment Variables",
  "name": "strapi-env-vars",
  "negativeExamples": [
    {
      "code": "export default ({ env }) => ({
  auth: {
    secret: process.env['ADMIN_JWT_SECRET']
  }
})",
      "language": "ts",
    },
    {
      "code": "export default ({ env }) => ({
  auth: {
    secret: process.env.ADMIN_JWT_SECRET
  }
})",
      "language": "ts",
    },
  ],
  "positiveExamples": [
    {
      "code": "export default ({ env }) => ({
  auth: {
    secret: env('ADMIN_JWT_SECRET')
  }
})",
      "language": "ts",
    },
  ],
  "source": "fixtures/rules/prefer-strapi-env-vars.md",
  "tags": [
    "code smells",
  ],
}
`;

exports[`parseRuleFile - fixtures/rules/wip/format-comments-like-sentences.md 1`] = `
{
  "desc": "Capitalize the first word unless it's a case-sensitive identifier. End it with a period (or "!" or "?", I suppose). This is true for all comments: doc comments, inline stuff, even TODOs. Even if it's a sentence fragment.",
  "fixable": true,
  "languages": [
    "all",
  ],
  "level": "error",
  "message": "Format comments like sentences",
  "name": "format-comments-like-sentences",
  "negativeExamples": [
    {
      "code": "// quick comment",
      "language": "ts",
    },
  ],
  "positiveExamples": [
    {
      "code": "// Quick comment.",
      "language": "ts",
    },
  ],
  "source": "fixtures/rules/wip/format-comments-like-sentences.md",
  "tags": [
    "general",
  ],
}
`;

exports[`parseRuleFile - fixtures/rules/wip/react-prefer-derived-state.md 1`] = `
{
  "desc": "State which is simple to derive should be re-derived when necessary instead of storing it in state or props.TODO",
  "fixable": false,
  "languages": [
    "javascript",
    "typescript",
  ],
  "level": "error",
  "message": "Prefer derived state in React",
  "name": "react-prefer-derived-state",
  "negativeExamples": [],
  "positiveExamples": [],
  "source": "fixtures/rules/wip/react-prefer-derived-state.md",
  "tags": [
    "react",
  ],
}
`;

exports[`parseRuleFile - guidelines/consistent-identifier-casing.md 1`] = `
{
  "desc": "Identifiers of the same type should try to use consistent casing.Variable names should use camelCase.
Global const variable names should either use camelCase, PascalCase, or CONSTANT_CASE.
Type names should use PascalCase.
Class names should use PascalCase.
Function names should use camelCase.Third-party APIs may use inconsistent casing, which is an exception to this rule.Keys in JSON objects, JS objects, and TypeScript objects may use inconsistent casing, so they are exceptions to this rule.Examples of camelCase identifiers include: foo, fooBar, h1RuleNodes, cwd, apiBaseUrl, apiBaseURL, validRuleTableKeysL, and _getKey.Ignore identifiers which mix PascalCase with camelCase.Ignore the casing of common acronyms like API, IP, HTTP, and LLM.Ignore the casing of identifiers which start with acronyms like LLMOptionsSchema.Class variables and functions may include _ prefixes.",
  "fixable": false,
  "languages": [
    "javascript",
    "typescript",
  ],
  "level": "error",
  "message": "Be consistent with identifier casing",
  "name": "consistent-identifier-casing",
  "negativeExamples": [
    {
      "code": "// These are bad because variable identifiers should use consistent casing.
const fooBar = true
const default_timeout = 5000

// These are bad because function identifiers should use consistent casing.
function helloWorld() {}
function hello_twitter() {}",
      "language": "ts",
    },
  ],
  "positiveExamples": [
    {
      "code": "const fooBar = true
const defaultTimeout = 5000

function helloWorld() {}
function helloTwitter() {}",
      "language": "ts",
    },
    {
      "code": "import foo from 'foo'

// This is fine because \`foo\` is a third-party API which this rule should to ignore.
foo({ camelCase: true, snake_case: true, SNAKE_CASE: true })",
      "language": "ts",
    },
    {
      "code": "export const HTTPConfig = {}
const LLMOptions = {}
const validKeysL = new Set()",
      "language": "ts",
    },
  ],
  "source": "guidelines/consistent-identifier-casing.md",
  "tags": [
    "general",
  ],
}
`;

exports[`parseRuleFile - guidelines/prefer-array-at-negative-indexing.md 1`] = `
{
  "desc": "When accessing items in an array from the end, like the last item, prefer using Array.at with a negative index because it is less error-prone. Note that using Array.at with a positive index is equivalent to indexing into the array normally, and if Array.at references a non-existing index, it will return undefined.",
  "fixable": true,
  "languages": [
    "javascript",
    "typescript",
  ],
  "level": "error",
  "message": "Prefer using Array.at when indexing from the end of an array",
  "name": "prefer-array-at-negative-indexing",
  "negativeExamples": [
    {
      "code": "const items = [1, 2, 3, 4, 5, 6, 7]
const lastItem = items[items.length - 1]",
      "language": "ts",
    },
  ],
  "positiveExamples": [
    {
      "code": "const items = [1, 2, 3, 4, 5, 6, 7]
const lastItem = items.at(-1)",
      "language": "ts",
    },
    {
      "code": "const items = [1, 2, 3, 4, 5, 6, 7]

// This example is fine because it uses a normal, positive index
const firstItem = items[0]",
      "language": "ts",
    },
    {
      "code": "const items = [1, 2, 3, 4, 5, 6, 7]
const index = example()

// This example is fine because it uses a variable index
const item = items[index]",
      "language": "ts",
    },
  ],
  "source": "guidelines/prefer-array-at-negative-indexing.md",
  "tags": [
    "general",
  ],
}
`;

exports[`parseRuleFile - guidelines/prefer-fetch-over-axios.md 1`] = `
{
  "desc": "The NPM package axios should be avoided in favor of native fetch. Now that native fetch has widespread support, axios is effectively deprecated and is generally a code smell when encountered.Convenience wrappers around fetch such as ky and ofetch are encouraged.Code which doesn't use the axios module should be ignored.",
  "fixable": false,
  "languages": [
    "javascript",
    "typescript",
  ],
  "level": "error",
  "message": "Prefer fetch over axios",
  "name": "prefer-fetch-over-axios",
  "negativeExamples": [],
  "positiveExamples": [],
  "source": "guidelines/prefer-fetch-over-axios.md",
  "tags": [
    "general",
  ],
}
`;

exports[`parseRuleFile - guidelines/react-avoid-class-components.md 1`] = `
{
  "desc": "React class components are deprecated. Use React functions and hooks instead.Note that uses classes is fine for non-react components.",
  "fixable": false,
  "languages": [
    "javascript",
    "typescript",
  ],
  "level": "error",
  "message": "Don't use React class components",
  "name": "react-avoid-class-components",
  "negativeExamples": [
    {
      "code": "import { Component } from 'react'

export class Label extends Component {
  render() {
    return <div>Hello</div>
  }
}",
      "language": "tsx",
    },
    {
      "code": "import react from 'react'

export class Label extends react.Component {
  render() {
    return <div />
  }
}",
      "language": "tsx",
    },
  ],
  "positiveExamples": [
    {
      "code": "export function Button() {
  return <div>Hello</div>
}",
      "language": "tsx",
    },
    {
      "code": "import EventEmitter from 'eventemitter3'

// This is fine because it is a normal class and not a React component.
class Foo extends EventEmitter {
  constructor() {}
}",
      "language": "ts",
    },
  ],
  "source": "guidelines/react-avoid-class-components.md",
  "tags": [
    "react",
  ],
}
`;

exports[`parseRuleFile - guidelines/semantic-variable-names.md 1`] = `
{
  "desc": "Variable names should be descriptive and capture the semantics of the value they represent. This makes it easier to read and understand code. It also makes it clearer when variables are being misused.An exception to this rule is that it is acceptable to use simple variable names like i in for loops.An exception to this rule is that math-heavy code may use simple variable names within the scope of a mathematically dense function.Common acronyms like api, ast, and llm are fine even though they aren't as descriptive.Variables names which mirror the corresponding type name are okay to ignore.Keys in objects and JS/TS strings are not variable names, so they should be ignored.If a value isn't a variable name, then it should be ignored.This rule should be ignored in test files.The names of file imports from third-party APIs and modules should be ignored because we have no control over them.If you are unsure whether or not a variable name is descriptive enough, err on the side of ignoring it or setting confidence to low.",
  "fixable": false,
  "languages": [
    "javascript",
    "typescript",
  ],
  "level": "error",
  "message": "Use semantic variable names",
  "name": "semantic-variable-names",
  "negativeExamples": [
    {
      "code": "// Bad because "a" is not a descriptive variable name
const a = 5

// Bad because "b" is not a descriptive variable name
const b = false",
      "language": "ts",
    },
  ],
  "positiveExamples": [
    {
      "code": "// Good because "numTokens" is descriptive
const numTokens = 5

// Good because "isFinished" is descriptive
const isFinished = true

// Good because "ast" is an acronym
const ast = parseAST()

// Good because "fileTypeToParserMap" is very descriptive
const fileTypeToParserMap: Record<string, string> = {}",
      "language": "ts",
    },
    {
      "code": "// "i" is okay here because it is a simple for loop
for (let i = 0; i < 10; i++) {}",
      "language": "ts",
    },
    {
      "code": "// "x", "y", and "r" are all okay here because they represent real, mathematical
// concepts, and concise variable names are often preferred in math-heavy code.
function normalDist(mu = 0, sigma = 1) {
  let x: number, y: number, r: number

  do {
    x = Math.random() * 2 - 1
    y = Math.random() * 2 - 1
    r = x * x + y * y
  } while (!r || r > 1)

  return mu + sigma * y * Math.sqrt((-2 * Math.log(r)) / r)
}",
      "language": "ts",
    },
    {
      "code": "// These are fine because the simple variable names match the corresponding type names.
const rule: Rule = {}
const data: Data = {}",
      "language": "ts",
    },
    {
      "code": "// This is fine because \`z\` is an external dependency that we have no control over.
import { z } from 'zod'",
      "language": "ts",
    },
  ],
  "source": "guidelines/semantic-variable-names.md",
  "tags": [
    "general",
  ],
}
`;

exports[`parseRuleFile - guidelines/use-esm.md 1`] = `
{
  "desc": "CommonJS code is deprecated and should be avoided going forwards. CommonJS code uses require and module.exports and suffers from poor standardization and interoperability issues.ESM (ECMAScript Modules) is a modern standard which uses import and export statements. It is preferred for all JS/TS code going forwards.",
  "fixable": false,
  "languages": [
    "javascript",
    "typescript",
  ],
  "level": "error",
  "message": "Use ESM instead of CommonJS",
  "name": "use-esm",
  "negativeExamples": [
    {
      "code": "const path = require('path')

module.exports = function foo() {}",
      "language": "js",
    },
  ],
  "positiveExamples": [
    {
      "code": "import path from 'path'

export default function foo() {}
export function bar() {}",
      "language": "js",
    },
  ],
  "source": "guidelines/use-esm.md",
  "tags": [
    "general",
  ],
}
`;
