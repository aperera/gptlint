// Vitest Snapshot v1, https://vitest.dev/guide/snapshot.html

exports[`parseRuleFile - fixtures/rules/empty-examples.md 1`] = `
{
  "desc": "This rule doesn't contain any examples which is fine because they are optional.",
  "message": "Example",
  "name": "example",
  "negativeExamples": [],
  "positiveExamples": [],
  "source": "fixtures/rules/empty-examples.md",
}
`;

exports[`parseRuleFile - fixtures/rules/force-list-pagination.md 1`] = `
{
  "desc": "Force the use of pagination for all lists in GraphQL.",
  "fixable": false,
  "languages": [
    "javascript",
    "typescript",
  ],
  "level": "error",
  "message": "Force List Pagination",
  "name": "force-list-pagination",
  "negativeExamples": [
    {
      "code": "type Query {
  items: [ItemConnection]
  requiredItems: [ItemConnection!]
  nestedRequireItems: [ItemConnection!]!
}",
      "language": "graphql",
    },
  ],
  "positiveExamples": [
    {
      "code": "type ListPaginationInput {
  first: Int
  last: Int
  after: String
  before: String
}

type Query {
  items(pagination: ): [ItemConnection]
  requiredItems: [ItemConnection!]
  nestedRequireItems: [ItemConnection!]!
}",
      "language": "graphql",
    },
  ],
  "source": "fixtures/rules/force-list-pagination.md",
  "tags": [
    "graphql",
  ],
}
`;

exports[`parseRuleFile - fixtures/rules/metadata-0.md 1`] = `
{
  "desc": "This example should parse correctly.",
  "eslint": [
    "example-eslint-rule-1",
    "example-eslint-rule-2",
  ],
  "fixable": false,
  "languages": [
    "javascript",
    "typescript",
  ],
  "level": "error",
  "message": "Example",
  "name": "example-name",
  "negativeExamples": [],
  "positiveExamples": [],
  "source": "fixtures/rules/metadata-0.md",
  "tags": [
    "general",
  ],
}
`;

exports[`parseRuleFile - fixtures/rules/metadata-1.md 1`] = `
{
  "desc": "This example should parse correctly because we stringify the values.",
  "eslint": [
    "example-eslint-rule-1",
    "@foo/example-eslint-rule-2",
  ],
  "fixable": false,
  "languages": [
    "javascript",
    "typescript",
  ],
  "level": "error",
  "message": "Example",
  "name": "example-name",
  "negativeExamples": [],
  "positiveExamples": [],
  "source": "fixtures/rules/metadata-1.md",
  "tags": [
    "general",
    "react",
  ],
}
`;

exports[`parseRuleFile - fixtures/rules/mutations.md 1`] = `
{
  "desc": "Disallow empty arguments for mutation Enforcing naming conventions for mutation input names and mutation return types.",
  "eslint": [
    "@ux-l_graphql-eslint/mutation-types",
  ],
  "fixable": false,
  "languages": [
    "javascript",
    "typescript",
  ],
  "level": "error",
  "message": "Mutation Inputs",
  "name": "mutation-types",
  "negativeExamples": [
    {
      "code": "type Mutation {
  setMessage(message: SetMessageInput, other: String): String
}
type Mutation {
  setMessage(message: String): String
}
type Mutation {
  setMessage: String
}
type Mutation {
  setMessage(input: setMessageInput): setMessageResponse
}",
      "language": "graphql",
    },
  ],
  "positiveExamples": [
    {
      "code": "type Mutation {
  setMessage(input: SetMessageInput): SetMessageResponse
}
type Mutation {
  setMessage(input: [SetMessageInput]): SetMessageResponse
}",
      "language": "graphql",
    },
  ],
  "source": "fixtures/rules/mutations.md",
  "tags": [
    "graphql",
  ],
}
`;

exports[`parseRuleFile - fixtures/rules/prefer-edge-node.md 1`] = `
{
  "desc": "Prefer usage of Edges and Nodes in GraphQL Lists.",
  "eslint": [
    "@ux-l_graphql-eslint/mutation-types",
  ],
  "fixable": false,
  "languages": [
    "javascript",
    "typescript",
  ],
  "level": "error",
  "message": "Prefer Edges & Nodes",
  "name": "prefer-edge-node",
  "negativeExamples": [
    {
      "code": "type Item {
  id: ID
  name: String
}

type Query {
  items: [Item]
  requiredItems: [Item!]
  nestedRequireItems: [Item!]!
}",
      "language": "graphql",
    },
  ],
  "positiveExamples": [
    {
      "code": "type Item {
  id: ID
  name: String
}

type ItemEdge {
  node: Node!
  cursor: String!
}

type ItemConnection {
  edges: [ItemEdge]
  pageInfo: PageInfo!
}

type PageInfo {
  endCursor: String
  hasNextPage: Boolean!
  resultCount: Int!
}

type Query {
  items: [ItemConnection]
  requiredItems: [ItemConnection!]
  nestedRequireItems: [ItemConnection!]!
}",
      "language": "graphql",
    },
  ],
  "source": "fixtures/rules/prefer-edge-node.md",
  "tags": [
    "graphql",
  ],
}
`;

exports[`parseRuleFile - fixtures/rules/prefer-page-queries.md 1`] = `
{
  "desc": "Warn on usage of the /utils/api.ts file in favor of creating a page query in the /utils/pageQueries folder.",
  "fixable": false,
  "languages": [
    "javascript",
    "typescript",
  ],
  "level": "error",
  "message": "Prefer page queries",
  "name": "prefer-page-queries",
  "negativeExamples": [
    {
      "code": "export const get<queryName>Data = async (
  locale: string
): Promise<<queryName>Type | null> => {
  try {
    const data = await fetchCmsGraphql(GET_<queryName>, {
      locale,
    });
    return data?.<queryName>?.data?.attributes || null;
  } catch (error) {
    console.error(error);
    return null;
  }
};",
      "language": "ts",
    },
  ],
  "positiveExamples": [
    {
      "code": "import { print } from 'graphql';
import {
  <queryName>Query,
  <queryName>QueryVariables,
} from './AboutUsPage.generated';
export type { <queryName>Query, <queryName>QueryVariables };
import QUERY from './AboutUsPage';
import { fetchCmsGraphql } from '../../fetchCmsData';

export const get<queryName>PageData = async (
  variables: <queryName>PageQueryVariables
): Promise<<queryName>Query | null> => {
  try {
    const data = await fetchCmsGraphql(print(QUERY), variables);
    return data as <queryName>Query;
  } catch (error) {
    console.error(error);
    return null;
  }
};",
      "language": "ts",
    },
    {
      "code": "import gql from 'graphql-tag'

export default gql\`
  query <queryName> {
    # query here
  }
\`",
      "language": "tsx",
    },
  ],
  "source": "fixtures/rules/prefer-page-queries.md",
  "tags": [
    "graphql",
  ],
}
`;

exports[`parseRuleFile - fixtures/rules/prefer-strapi-env-vars.md 1`] = `
{
  "desc": "Avoid accessing process.env variables in favor of Strapi environment variables.",
  "fixable": true,
  "languages": [
    "javascript",
    "typescript",
  ],
  "level": "error",
  "message": "Use Strapi Environment Variables",
  "name": "strapi-env-vars",
  "negativeExamples": [
    {
      "code": "export default ({ env }) => ({
  auth: {
    secret: process.env['ADMIN_JWT_SECRET']
  }
})",
      "language": "ts",
    },
    {
      "code": "export default ({ env }) => ({
  auth: {
    secret: process.env.ADMIN_JWT_SECRET
  }
})",
      "language": "ts",
    },
  ],
  "positiveExamples": [
    {
      "code": "export default ({ env }) => ({
  auth: {
    secret: env('ADMIN_JWT_SECRET')
  }
})",
      "language": "ts",
    },
  ],
  "source": "fixtures/rules/prefer-strapi-env-vars.md",
  "tags": [
    "code smells",
  ],
}
`;

exports[`parseRuleFile - guidelines/avoid-react-class-components.md 1`] = `
{
  "desc": "React class components are deprecated. Use React functions and hooks instead.",
  "fixable": false,
  "languages": [
    "javascript",
    "typescript",
  ],
  "level": "error",
  "message": "Don't use React class components",
  "name": "avoid-react-class-components",
  "negativeExamples": [
    {
      "code": "class Label extends Component {
  render() {
    return <div>Hello</div>
  }
}",
      "language": "tsx",
    },
  ],
  "positiveExamples": [
    {
      "code": "function Button() {
  return <div>Hello</div>
}",
      "language": "tsx",
    },
  ],
  "source": "guidelines/avoid-react-class-components.md",
  "tags": [
    "react",
  ],
}
`;

exports[`parseRuleFile - guidelines/consistent-identifier-casing.md 1`] = `
{
  "desc": "Identifiers of the same type should use consistent casing. This rule applies to all types of identifiers: variable names, class names, type names, function names, constants, etc.For example, if some variable names use camelCase, then all variable names should use camelCase. If some type names use PascalCase, then all type names should use PascalCase. If some constants use CONSTANT_CASE, then all constants should use constant case.",
  "fixable": false,
  "languages": [
    "all",
  ],
  "level": "error",
  "message": "Be consistent with identifier casing",
  "name": "consistent-identifier-casing",
  "negativeExamples": [
    {
      "code": "// This is bad because variable identifiers should use consistent casing.
const fooBar = true
const default_timeout = 5000

// This is bad because function identifiers should use consistent casing.
function helloWorld() {}
function hello_twitter() {}",
      "language": "ts",
    },
  ],
  "positiveExamples": [
    {
      "code": "const fooBar = true
const defaultTimeout = 5000

function helloWorld() {}
function helloTwitter() {}",
      "language": "ts",
    },
  ],
  "source": "guidelines/consistent-identifier-casing.md",
  "tags": [
    "general",
  ],
}
`;

exports[`parseRuleFile - guidelines/format-comments-like-sentences.md 1`] = `
{
  "desc": "Capitalize the first word unless it's a case-sensitive identifier. End it with a period (or "!" or "?", I suppose). This is true for all comments: doc comments, inline stuff, even TODOs. Even if it's a sentence fragment.",
  "fixable": true,
  "languages": [
    "all",
  ],
  "level": "error",
  "message": "Format comments like sentences",
  "name": "format-comments-like-sentences",
  "negativeExamples": [
    {
      "code": "// quick comment",
      "language": "ts",
    },
  ],
  "positiveExamples": [
    {
      "code": "// Quick comment.",
      "language": "ts",
    },
  ],
  "source": "guidelines/format-comments-like-sentences.md",
  "tags": [
    "general",
  ],
}
`;

exports[`parseRuleFile - guidelines/prefer-array-at-negative-indexing.md 1`] = `
{
  "desc": "When accessing items in an array from the end, like the last item, prefer using Array.at with a negative index because it is less error-prone. Note that using Array.at with a positive index is equivalent to indexing into the array normally, and if Array.at references a non-existing index, it will return undefined.",
  "fixable": true,
  "languages": [
    "javascript",
    "typescript",
  ],
  "level": "error",
  "message": "Prefer using Array.at when indexing from the end of an array",
  "name": "prefer-array-at-negative-indexing",
  "negativeExamples": [
    {
      "code": "const items = [1, 2, 3, 4, 5, 6, 7]
const lastItem = items[items.length - 1]",
      "language": "ts",
    },
  ],
  "positiveExamples": [
    {
      "code": "const items = [1, 2, 3, 4, 5, 6, 7]
const lastItem = items.at(-1)",
      "language": "ts",
    },
  ],
  "source": "guidelines/prefer-array-at-negative-indexing.md",
  "tags": [
    "general",
  ],
}
`;

exports[`parseRuleFile - guidelines/semantic-variable-names.md 1`] = `
{
  "desc": "Variable names should be descriptive and capture the semantics of the value they represent. This makes it easier to read and understand code. It also makes it clearer when variables are being misused.An exception to this rule is that it is acceptable to use simple variable names like i in for loops.An exception to this rule is that math-heavy code may use simple variable names within the scope of a mathematically dense function.",
  "fixable": false,
  "languages": [
    "all",
  ],
  "level": "error",
  "message": "Use semantic variable names",
  "name": "semantic-variable-names",
  "negativeExamples": [
    {
      "code": "// Bad because "a" is not a descriptive variable name
const a = 5

// Bad because "b" is not a descriptive variable name
const b = false",
      "language": "ts",
    },
  ],
  "positiveExamples": [
    {
      "code": "// Good because "numTokens" is descriptive
const numTokens = 5

// Good because "isFinished" is descriptive
const isFinished = true",
      "language": "ts",
    },
    {
      "code": "// "i" is okay here because it is a simple for loop
for (let i = 0; i < 10; i++) {}",
      "language": "ts",
    },
    {
      "code": "// "x", "y", and "r" are all okay here because they represent real, mathematical
// concepts, and concise variable names are often preferred in math-heavy code.
function normalDist(mu = 0, sigma = 1) {
  let x: number, y: number, r: number

  do {
    x = Math.random() * 2 - 1
    y = Math.random() * 2 - 1
    r = x * x + y * y
  } while (!r || r > 1)

  return mu + sigma * y * Math.sqrt((-2 * Math.log(r)) / r)
}",
      "language": "ts",
    },
  ],
  "source": "guidelines/semantic-variable-names.md",
  "tags": [
    "general",
  ],
}
`;

exports[`parseRuleFile - guidelines/use-esm.md 1`] = `
{
  "desc": "CommonJS code is deprecated and should be avoided going forwards. CommonJS code uses require and module.exports and suffers from poor standardization and interoperability issues.ESM (ECMAScript Modules) is a modern standard which uses import and export statements. It is preferred for all JS/TS code going forwards.",
  "fixable": false,
  "languages": [
    "javascript",
    "typescript",
  ],
  "level": "error",
  "message": "Use ESM instead of CommonJS",
  "name": "use-esm",
  "negativeExamples": [
    {
      "code": "const path = require('path')

module.exports = function () {}",
      "language": "js",
    },
  ],
  "positiveExamples": [
    {
      "code": "import path from 'path'

export default function () {}",
      "language": "js",
    },
  ],
  "source": "guidelines/use-esm.md",
  "tags": [
    "general",
  ],
}
`;
